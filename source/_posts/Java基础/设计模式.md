---
title: 设计模式
date: 2020-05-21 14:33:00
categories: Java基础
tags: [设计模式]

---

### 设计模式7大原则

| 原则         | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| 开闭原则     | 对扩展开发、对修改关闭                                       |
| 依赖倒置原则 | 抽象不应该依赖于细节，细节应该依赖抽象。换言之，要针对接口编程，不是实现编程 |
| 单一职责原则 | 一个类或一个方法干一件事                                     |
| 接口隔离原则 | 使用多个专门的接口，不是使用一个总接口，即客户端不应该依赖那些它不需要的接口 |
| 迪米特法则   | 降低耦合性                                                   |
| 里氏替换原则 | 可以用父类，就可以用子类代替                                 |
| 合成复用原则 | 多组合聚合，少继承                                           |

### 单例模式

保证一个类仅有一个实例，并提供一个访问它的全局访问点

#### 饿汉式

类加载时就初始化，好像很饿的样子，优点是没有加锁执行效率很高，缺点是浪费内存

实现方式一

```java
    private static final HungrySingleton hungrySingleton = new HungrySingleton();

    private HungrySingleton(){

    }

    public static HungrySingleton getInstance(){
        return hungrySingleton;
    }
```

实现方式二

```java
    private static final HungryStaticSingleton hungryStaticSingleton;

    static {
        hungryStaticSingleton = new HungryStaticSingleton();
    }

    private HungryStaticSingleton(){

    }

    public static HungryStaticSingleton getInstance(){
        return hungryStaticSingleton;
    }

```

#### 懒汉式

第一次使用时才初始化，比较懒，优点是节省内存，缺点是需要加synchronized

传统懒汉式(不建议使用)

```java
public class Singleton {  
    private static Singleton instance;  
    private Singleton (){}  
    public static synchronized Singleton getInstance() {  
    if (instance == null) {  
        instance = new Singleton();  
    }  
    return instance;  
    }  
}
```

双重检查锁懒汉式

在多线程情况下能保持高性能

```java
private volatile static LazyDoubleCheckSingleton lazy = null;

    private LazyDoubleCheckSingleton(){

    }
    //双重检查锁
    public static LazyDoubleCheckSingleton getInstance(){
        if(lazy == null){
            synchronized (LazyDoubleCheckSingleton.class){
                if(lazy == null){
                    lazy = new LazyDoubleCheckSingleton();
                    //CPU执行时候会转换成JVM指令执行

                    //指令重排序问题，volatile关键字（解决通常CPU在执行第2和第3的时候没有顺序的问题）
                    //1、分配内存给这个对象
                    //2、初始化对象
                    //3、将初始化好的对象和内存地址建立关联，赋值
                    //4、用户初次访问

                }
            }
        }
        return lazy;
    }
```

静态内部类懒汉式

全程没有用synchronized，性能高

```java
    //虽然构造方法私有了，但是逃不过反射的法眼
    private LazyInnerClassSingleton (){
        if(LazyHolder.LAZY != null){
            throw new RuntimeException("不允许构建多个实例");
        }
    }

    //懒汉式单例
    //LazyHolder 里面的逻辑需要等到外部调用时才执行
    //巧妙地运用了内部类的特性
    //JVM底层执行逻辑，完美地避免了线程安全问题
    public static  final LazyInnerClassSingleton getInstance(){
        return LazyHolder.LAZY;
    }

    private static class LazyHolder{
        private static final LazyInnerClassSingleton LAZY = new LazyInnerClassSingleton();
    }
```

枚举式

```java
public enum Singleton {  
    INSTANCE;  
    public void whateverMethod() {  
    }  
}
```

#### 破坏单例模式的方法

1、多线程，如果懒汉式单例是线程不安全的可以通过此方式破坏

2、反射，通过反射调用实例化方法

3、序列化，序列化之后再通过反射调用构造器进行创建实例





### 代理模式

代理模式分为静态代理和动态代理，动态代理有Jdk代理和Cglib代理，

jdk动态代理原理是在编译时生成了一个新的字节码文件$Proxy0.class，它是通过用代码写代码的方式写了一个新的类，然后自己编译的

```java
public class JDKMeipo implements InvocationHandler {

    private Person person;

    public Object getInstance(Person person)throws Exception{
        this.person = person;
        Class<?> clazz = person.getClass();
//        Person.class.getClassLoader();
        return Proxy.newProxyInstance(Person.class.getClassLoader(),clazz.getInterfaces(),this);
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        before();
        Object obj = method.invoke(this.person, args);
        after();
        return obj;
    }

    //功能增强
    private void before(){
        System.out.println("我是媒婆，我要给你找对象");
        System.out.println("开始验货");
    }

    private void after(){
        System.out.println("OK");
    }

}
```

### 工厂模式

#### 工厂模式有几种，区别是啥

简单工厂、工厂方法、抽象工厂





### 模板模式

#### 模板模式除了继承外，还有哪些实现方式？

答：还可以聚合





### 设计模式总结

| 设计模式                | 说明                                           | 举例                                                |
| ----------------------- | ---------------------------------------------- | --------------------------------------------------- |
| 工厂模式（Factory）     | 只对结果负责，封装创建过程                     | BeanFactory、Calender                               |
| 单例模式（Singleton）   | 保证独一无二                                   | ApplicationContext、Calender                        |
| 原型模式（Prototype）   | 拔一根猴毛，吹出千万个                         | ArrayList、PrototypeBean                            |
| 代理模式（Proxy）       | 找人办事，增强职责                             | ProxyFactoryBean、JdkDynamicAopProxy、CglibAopProxy |
| 委派模式（Delegate）    | 干活算你的（普通员工），功劳算我的（项目经理） | DispatcherServlet、BeanDefinitionParserDelegate     |
| 策略模式（Strategy）    | 用户选择、结果统一                             | InstantiationStrategy                               |
| 模板模式（Template）    | 流程标准化，实现自己定制                       | JdbcTemplate、HttpServlet                           |
| 适配器模式（Adapter）   | 兼容转换头                                     | AdvisorAdapter、HandlerAdapter                      |
| 装饰器模式（Decorator） | 包装、同宗同源                                 | BufferedReader、InputStream、OutputStream           |
| 观察者模式（Observer）  | 任务完成时通知                                 | ContextLoaderListener                               |
| 责任链模式              |                                                |                                                     |

