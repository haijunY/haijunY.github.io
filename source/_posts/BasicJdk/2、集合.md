---
title: 2、集合
date: 2019-11-03 15:00:00
categories: Java基础
tags: [集合]

---

### List、Set、Map的区别

List：
1.可以允许重复的对象
          2.可以插入多个null元素
          3.是一个有序容器
          4.实现类有ArrayList、LinkedList和Vector。ArrayList有索引，索引更加用于频繁查询，            LinkedList是链表结构，所以适用于频繁添加和删除
Set：
1.不允许重复对象
2.无序容器
3.只允许一个null
4.流行的实现类有HashSet、LinkedHashSet和TreeSet。最流行的是基于HashMap实现的HashSet
Map：
1.Map是一个键值对的的Entry数组，key是唯一的，value可重复、可为null
2.流行的实现类有HashMap、LinkedHashMap、Hashtable、TreeMap、ConcurrentHashMap，
HashMap线程不安全性能高，Hashtable线程安全性能低，ConcurrentHashMap线程安全性能高

### HashMap

HashMap是一种数组加链表的数据结构，数组的初始容量为16，扩容因子为0.75，每次扩容后数组大小X2，并且一定是2的幂次方倍

当HashMap插入一条数据时，对Key计算hashCode，然后与当前的容量-1进行做&运算，其结果就是当前这条数据需要放入的数组下标，那么，不可避免的是，一定会出现运算结果相同的情况（注意不一定是HashCode相同，如果是Key完全相同就替换），那么同一个数组下标的元素会以链表的数据结构存储，以next指向下一个元素，如果链表的长度大于8，在jdk1.8以后，会转化成红黑树

红黑树

红黑是一种数据结构，要了解红黑树，我们需要先了解二叉树 -> 二叉查找树 -> 二叉平衡查找树，那么红黑树就是一种接近平衡的二叉查找树，这样做是问了提供查询性能，具有五个特性：

每个节点非红即黑

根节点一定是黑

红节点的子节点一定是黑

每个叶子节点是空的黑色节点

从一个节点到该节点的子孙节点所包含的黑色节点数目相同

HashMap中，有新的元素插入红黑树的时候，不管怎样，都需要满足其特性，它根据旋转算法去实现，分为左旋和右旋

<img src="../../images/左旋和右旋动态图.gif">


扩容

当超过扩容因子0.75的时候，会进行扩容，创建一个新的大小X2的数组，然后把原来的元素进行一一复制到新的数组中，在新的数组中会重新计算HashCode&(数组大小-1)的值，然后决定放入具体哪个位置

### ConcurrentHashMap

线程安全的HashMap，和HashMap数据结构，红黑树，扩容都有类似之处，不同的实现如下：

size大小的计算：

ConcurrenctHashMap对于size这里有优化，因为是在并发的环境下，如果使用一个volitile修饰的size来实现，虽然线程安全可以保证，但是效率低下，为了解决此问题Doug Lea采用了一种以空间换时间的思想，把size按cpu核心数来分成多个，以一个CounterCell数组保存，比如是4核CPU，则是一个大小为4的数组对象来保存size的，这样并发环境下，系统会根据规则加在某一个数组元素之中，这样就提高了效率，最终在计算size()的时候，只需要把他们相加即可

扩容的优化：

ConcurrentHashMap对于扩容这块也做了相应的优化，主要体现在两个地方

一、元素的分批迁移，多线程环境下，当线程A发生扩容的时候，会记录一个状态，线程B添加元素时，如果此时正在进行扩容，则会一起帮助迁移，因为此时数组根据当前的长度把它划分成了若干个片区，如果有新的线程加入，则会执行对应的片区迁移，直到所有片区全部迁移完成，则扩容完成，这也是一个空间换时间的思想

二、链表或红黑树迁移时的优化，常规操作下，元素迁移时，会一个个地计算HashCode值，然后与数组长度-1进行&运算，从而得到新的数组下标，但这里做了一个优化，首先把同一个链表底下的元素进行分类，分为高位类和低位类，怎么分的呢，用HashCode&（数组长度-1）的结果，如果第一位为1则是高位类，为0是低位类，然后把所有的高位元素的数组下标+原来的数组长度得到新的数组下标，而低位类的数组下标保持不变，如此一来就不用逐个去计算和挪动了，大大提高效率

1、ConcurrentHashMap1.8中是基于什么机制来保证线程安全性的？

​		put操作时，通过自旋保证最终成功，采用CAS方式插入头结点（数组上的那个节点），用synchronized锁住头节点来保证插入链表(或红黑树)的节点线程安全

​		remove操作时也是同理，通过自旋保证最终成功，采用CAS方式删除头节点，用synchronized锁住头节点来保证删除链表的节点是线程安全的

2、ConcurrentHashMap通过get方法获取数据的时候，是否需要通过加锁来保证数据的可见性？为什么？

​		Node中val和next是用volatile修饰的，那么在添加的时候是对其它线程可见的，所以不需要加锁保证

3、ConcurrentHashMap1.7和ConcurrentHashMap1.8有哪些区别？

​		取消了segment分段设计，直接采用node数组来保存数据，这样降低了粒度，使得效率更高

​		引入红黑树数据结构

4、ConcurrentHashMap1.8为什么要引入红黑树？

​		对于链表长度大于8，数组大小扩容到64时，会将链表修改成红黑树，对于数据量大的情况，查询效率提升明显

### HashSet是如何保证不重复的？

1.首先需要知道hashcode()方法和equals()方法
java中存在一种hash表结构，它通过一种算法，计算出的结果是hash码值；这个算法叫hash算法
hash算法是怎么计算的呢，是通过对象中的成员来计算，如果成员变量是基本数据类型，那么用这个值直接参与计算，如果是引用类型，那么获取这个成员变量的hash值后再参与计算
2.是否存入新元素，首先判断hash码，如果hash码不同，说明是新元素，存入，如果hash码相同，再判断equals，不相等则是新元素，存入，相等不存入

源码：https://github.com/haijunY/demos-past/tree/master/basic-jdk