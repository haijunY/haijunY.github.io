---
title: 知识全总结
date: 2019-11-03 15:00:00
categories: 面试
tags: [面试]
---

# 基础



### 克隆

浅克隆：基本类型和String会复制，引用类型指向地址，实现方式：类实现clone接口

深克隆：基本类型和String会复制，引用类型复制，实现方式：转化为字节流输出后再转化回来(序列化和反序列化)，或者重写clone()方法把引用属性都new一遍

### 受检异常和非受检异常

java.lang.Throwable

- Error
- Exception
  - RuntimeException(非受检异常，可以不处理)
  - 其它，如IOException、SQLException(受检异常，必须处理，不然编译报错)

PS:我们在设计自定义异常的时候，一般设计成非受检异常，保证代码美观，但是一旦此异常影响了系统的稳定性，就设计成受检异常

### 乐观锁和悲观锁

乐观锁：CAS替换，用version做版本控制

悲观锁：synchronized，select * from table for update

### BIO、NIO、AIO



### J.U.C

### AQS



## JVM

### 内存布局

### 有哪些GC

### CMS和G1

### 调优

### GCROOT,虚拟机栈可以成为GCROOT的原因

### ClassLoader有几种，通过一段代码打印出几种ClassLoader





### 强引用、软引用、弱引用、虚引用

强引用：平时最常用的，在内存不足的情况GC也不会回收，抛出OOM

软引用SoftReference：在内存不足情况下被回收，避免OOM

弱引用WeakReference：有GC执行时会被回收

虚引用PhantomReference：与ReferenceQueue一起使用，get()的值一直是null

## Mysql

### mysql体系架构

### mysql调优思路

### 为什么mysql的符合索引是遵循最左匹配原则

### 索引的本质是什么，B+树，为什么采用B+树

### mysql优化器工作原理





# 分布式

### TCP/IP四层网络模型

应用层：请求发起

传输层：TCP头+Http请求报文

网络层：IP头+TCP头+Http请求报文，可做三层负载，根据IP来负载

网络接口层：Mac地址+IP头+TCP头+Http请求报文，可做二层负载，根据Mac地址去负载

### TCP三次握手和四次挥手

第一次握手：客户端发送SYN包(seq=x)到服务器，并进入SYN_SEND状态，等待服务器确认

第二次握手：服务器收到SYN包，必须确认客户端ACK(ack=x+1)，同时自己也发送一个syn包(seq=y)，服务器进入SYN_RECV状态

第三次握手：客户端收到服务器的Syn+Ack包，向服务器发送确认包Ack(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手

第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动方的数据传送

第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1

第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送

第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手

<img src="../images/TCP三次握手四次挥手.jpg">

### 什么是幂等，如何实现

幂等是同一个业务请求，重复请求时候需要返回相同结果

方式一：利用数据库的唯一索引实现，请求的时候生成一个唯一请求号先插入一条数据，如果重复请求就会报错

方式二：用redis实现，生成一个唯一单号，放入redis，请求的时候先去查redis中是否有数据，有则表示重复请求

### 缓存穿透

正常情况下，一个请求会先去缓存中取数据，如果存在则返回，不存在则查询数据库，当发生大量查询空数据的情况下，会不断地查询数据库，从而导致数据库宕机，这种现象叫缓存穿透

方案一：对于查询为空的数据设置一个虚拟的value值(比如"&&")，放入缓存中，则可避免数据库被再次访问

方案二：在缓存之上加入布隆过滤器，布隆过滤器是一个不精确的Set结构，当布隆过滤器说不存在时一定不存在，存在时可能不存在，这样就会过滤掉大量的空的查询攻击

### Nginx

是一个高性能的反向代理服务器

正向代理代理的是客户端

反向代理代理的是服务端

### 数据库和缓存双写如何保证数据一致性

先操作数据库还是先操作缓存：根据业务场景来

更新缓存还是删除缓存：根据缓存更新是否复杂来

最终一致性：如果更新或删除缓存失败，可以把任务加入到MQ队列中，然后用一个消费端去异步执行保证最终一致性，当然这样的场景是在业务中容忍一定延迟的前提下

### 请设计一个高性能分布式调度框架

# 微服务







